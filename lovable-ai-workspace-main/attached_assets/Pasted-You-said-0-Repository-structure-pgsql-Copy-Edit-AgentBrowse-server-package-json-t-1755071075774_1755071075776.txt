You said:
0) Repository structure
pgsql
Copy
Edit
AgentBrowse/
├─ server/
│  ├─ package.json
│  ├─ tsconfig.json
│  ├─ .env.example
│  ├─ prisma/
│  │  └─ schema.prisma
│  └─ src/
│     ├─ index.ts
│     ├─ middleware/
│     │  ├─ auth.ts
│     │  ├─ entitlement.ts
│     │  └─ sizeLimit.ts
│     ├─ routes/
│     │  ├─ users.ts
│     │  ├─ payments.razorpay.ts
│     │  ├─ admin.ts
│     │  ├─ files.upload.ts
│     │  ├─ files.download.ts
│     │  ├─ files.analyze.ts
│     │  ├─ sheets.map.preview.ts
│     │  └─ sheets.map.apply.ts
│     ├─ services/
│     │  ├─ time.ts
│     │  ├─ trialRules.ts
│     │  ├─ trialUsage.ts
│     │  ├─ pythonAgent.ts
│     │  ├─ xlsxWriter.ts
│     │  ├─ mergeEngine.ts
│     │  └─ email.ts
│     └─ types/global.d.ts
├─ python_backend/
│  ├─ requirements.txt
│  ├─ main.py                ← REPLACE (verbatim; includes pause/resume + watchdog)
│  ├─ agent_browser_controller.py  ← REPLACE
│  └─ websocket_manager.py         ← REPLACE
└─ web/
   ├─ package.json
   ├─ vite.config.ts
   └─ src/
      ├─ main.tsx
      ├─ App.tsx
      ├─ pages/
      │  ├─ Pricing.tsx
      │  └─ AdminDashboard.tsx
      ├─ components/
      │  ├─ LeftPanel.tsx
      │  ├─ RightPanel.tsx
      │  ├─ FileDropzone.tsx
      │  └─ SheetGridPreview.tsx
      ├─ hooks/
      │  └─ use-websocket.ts      ← REPLACE (your file)
      └─ lib/firebase.ts
1) SERVER (Node/Express/TypeScript)
server/package.json
json
Copy
Edit
{
  "name": "agentbrowse-server",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "tsx src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "db:gen": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:deploy": "prisma migrate deploy"
  },
  "dependencies": {
    "@prisma/client": "^5.17.0",
    "cors": "^2.8.5",
    "date-fns": "^3.6.0",
    "express": "^4.18.2",
    "form-data": "^4.0.0",
    "luxon": "^3.5.0",
    "multer": "^1.4.5-lts.1",
    "node-fetch": "^3.3.2",
    "razorpay": "^2.9.5",
    "sendgrid": "^5.2.3",
    "@sendgrid/mail": "^7.7.0"
  },
  "devDependencies": {
    "prisma": "^5.17.0",
    "tsx": "^4.16.2",
    "typescript": "^5.4.5"
  }
}
server/tsconfig.json
json
Copy
Edit
{
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*", "types/**/*"]
}
server/.env.example
ini
Copy
Edit
PORT=7070
MAX_UPLOAD_MB=25

# Firebase Admin
GOOGLE_APPLICATION_CREDENTIALS=./service-account.json

# Razorpay
RAZORPAY_KEY_ID=your_key_id
RAZORPAY_KEY_SECRET=your_key_secret
PLAN_MONTHLY_ID=plan_xxxxxxxx

# Sendgrid
SENDGRID_API_KEY=SG.xxxxxxxx

# Admin allowlist
ADMIN_EMAILS=you@company.com,founder@company.com

# Python backend
PY_BACKEND=http://localhost:8000

# CORS (optional)
CORS_ORIGINS=http://localhost:5173
server/prisma/schema.prisma
prisma
Copy
Edit
datasource db { provider = "sqlite" url = "file:./dev.db" } // swap to postgres in prod
generator client { provider = "prisma-client-js" }

model User {
  id                      String   @id @default(cuid())
  email                   String   @unique
  name                    String?
  authProvider            String
  createdAt               DateTime @default(now())

  // Trial controls
  trialPeriodStartAt      DateTime?
  trialPeriodEndsAt       DateTime?     // start + 30 days
  trialUsedDates          Json?         // array of IST date keys used: ["2025-08-13", ...]
  trialDailyKey           String?       // current IST date key
  trialDailyUsedSeconds   Int           @default(0) // 0..900 (15min)

  subscription            Subscription?
  usageEvents             UsageEvent[]
  emailLogs               EmailLog[]
}

model Subscription {
  id                 String   @id @default(cuid())
  userId             String   @unique
  provider           String
  providerCustomerId String
  providerSubId      String?
  status             String   // "active" | "canceled" | "expired"
  currentPeriodEnd   DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id])
}

model UsageEvent {
  id        String   @id @default(cuid())
  userId    String
  type      String   // "login" | "upload" | "start_agent" | ...
  meta      Json
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model EmailLog {
  id        String   @id @default(cuid())
  userId    String
  type      String   // "welcome" | "receipt"
  status    String   // "sent" | "failed"
  meta      Json
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}
server/src/types/global.d.ts
ts
Copy
Edit
declare namespace NodeJS {
  interface ProcessEnv {
    PORT?: string;
    MAX_UPLOAD_MB?: string;
    GOOGLE_APPLICATION_CREDENTIALS?: string;
    RAZORPAY_KEY_ID?: string;
    RAZORPAY_KEY_SECRET?: string;
    PLAN_MONTHLY_ID?: string;
    SENDGRID_API_KEY?: string;
    ADMIN_EMAILS?: string;
    PY_BACKEND?: string;
    CORS_ORIGINS?: string;
  }
}
server/src/services/time.ts
ts
Copy
Edit
import { DateTime } from "luxon";
export const IST = "Asia/Kolkata";

export function nowIST(): Date {
  return DateTime.now().setZone(IST).toJSDate();
}

export function toISTKey(d: Date): string {
  return DateTime.fromJSDate(d).setZone(IST).toFormat("yyyy-LL-dd");
}

export function secondsUntilMidnightIST(d?: Date): number {
  const dt = (d ? DateTime.fromJSDate(d) : DateTime.now()).setZone(IST);
  const end = dt.endOf("day");
  return Math.max(0, Math.floor(end.diff(dt, "seconds").seconds));
}
server/src/services/trialRules.ts
ts
Copy
Edit
import { PrismaClient } from "@prisma/client";
import { nowIST, toISTKey } from "./time";

const db = new PrismaClient();
const MAX_DAYS = 5;
const DAILY_SECONDS = 15 * 60;
const WINDOW_DAYS = 30;

export async function getTrialState(email: string) {
  const user = await db.user.findUnique({ where: { email } });
  if (!user) return { allowed: false, reason: "NO_USER" as const };

  const now = nowIST();
  const todayKey = toISTKey(now);

  // Initialize 30-day window on first use
  let periodStart = user.trialPeriodStartAt;
  let periodEnd = user.trialPeriodEndsAt;
  if (!periodStart || !periodEnd) {
    return { allowed: true, needInit: true, todayKey, usedDates: [], remainingDays: MAX_DAYS, dailyLeft: DAILY_SECONDS };
  }

  // Check 30-day window
  if (now >= periodEnd) {
    return { allowed: false, reason: "TRIAL_WINDOW_OVER" as const, todayKey, usedDates: user.trialUsedDates ?? [] };
  }

  const usedDates: string[] = Array.isArray(user.trialUsedDates) ? (user.trialUsedDates as string[]) : [];
  const daysUsed = usedDates.length;
  const remainingDays = Math.max(0, MAX_DAYS - daysUsed);

  // Daily reset if new day
  let dailyUsed = user.trialDailyUsedSeconds || 0;
  if (user.trialDailyKey !== todayKey) {
    dailyUsed = 0;
  }
  const dailyLeft = Math.max(0, DAILY_SECONDS - dailyUsed);

  return {
    allowed: true,
    todayKey,
    usedDates,
    remainingDays,
    dailyLeft
  };
}

export async function consumeToday(email: string) {
  const user = await db.user.findUnique({ where: { email } });
  if (!user) throw new Error("NO_USER");
  const now = nowIST();
  const todayKey = toISTKey(now);

  // Init 30-day window on first consumption
  let usedDates: string[] = Array.isArray(user.trialUsedDates) ? (user.trialUsedDates as string[]) : [];
  let data: any = {};

  if (!user.trialPeriodStartAt || !user.trialPeriodEndsAt) {
    const start = now;
    const end = new Date(start.getTime() + WINDOW_DAYS * 24 * 60 * 60 * 1000);
    data.trialPeriodStartAt = start;
    data.trialPeriodEndsAt = end;
    usedDates = [];
  }

  // If new IST day, reset daily counters
  if (user.trialDailyKey !== todayKey) {
    data.trialDailyKey = todayKey;
    data.trialDailyUsedSeconds = 0;
  }

  // Mark today as one of the 5 distinct days (if not already)
  usedDates = usedDates.includes(todayKey) ? usedDates : [...usedDates, todayKey];
  if (usedDates.length > MAX_DAYS) throw new Error("TRIAL_DAYS_EXHAUSTED");

  data.trialUsedDates = usedDates;

  await db.user.update({ where: { id: user.id }, data });
  return { todayKey, usedDates };
}

export const TRIAL_CONSTANTS = { MAX_DAYS, DAILY_SECONDS, WINDOW_DAYS };
server/src/services/trialUsage.ts
ts
Copy
Edit
import { PrismaClient } from "@prisma/client";
import { nowIST, secondsUntilMidnightIST } from "./time";
import { stopAgent } from "./pythonAgent";

const db = new PrismaClient();

// In-memory per-user timers and live sessions
const RUNNING = new Map<string, { start: number; sessions: Set<string> }>();
const SESSIONS_BY_USER = new Map<string, Set<string>>();

export async function beginTrialSession(email: string, sessionId: string) {
  const now = nowIST().getTime();
  const cur = RUNNING.get(email) || { start: now, sessions: new Set() };
  cur.start = now;
  cur.sessions.add(sessionId);
  RUNNING.set(email, cur);

  const map = SESSIONS_BY_USER.get(email) || new Set();
  map.add(sessionId);
  SESSIONS_BY_USER.set(email, map);

  return secondsUntilMidnightIST();
}

export async function endTrialSession(email: string, sessionId: string) {
  const cur = RUNNING.get(email);
  if (cur) {
    cur.sessions.delete(sessionId);
    const deltaSec = Math.max(0, Math.floor((nowIST().getTime() - cur.start) / 1000));
    RUNNING.delete(email);

    const user = await db.user.findUnique({ where: { email } });
    if (user) {
      await db.user.update({
        where: { id: user.id },
        data: { trialDailyUsedSeconds: (user.trialDailyUsedSeconds || 0) + deltaSec }
      });
    }
  }
}

export async function resetUserSessions(email: string) {
  const sessions = Array.from(SESSIONS_BY_USER.get(email) || []);
  await Promise.allSettled(sessions.map((sid) => stopAgent(sid)));
  RUNNING.delete(email);
  SESSIONS_BY_USER.delete(email);
}
server/src/services/pythonAgent.ts
ts
Copy
Edit
import fetch from "node-fetch";

const PY = process.env.PY_BACKEND || "http://localhost:8000";

export async function startAgent(sessionId: string, task: string, model?: string, maxSeconds?: number) {
  const body = new URLSearchParams();
  body.set("task", task);
  body.set("session_id", sessionId);
  if (model) body.set("model", model);
  if (maxSeconds !== undefined) body.set("max_seconds", String(maxSeconds)); // watchdog

  const r = await fetch(${PY}/start, { method: "POST", body });
  return r.json();
}

export async function stopAgent(sessionId: string) {
  const body = new URLSearchParams();
  body.set("session_id", sessionId);
  const r = await fetch(${PY}/stop, { method: "POST", body });
  return r.json();
}

export async function pauseAgent(sessionId: string) {
  const body = new URLSearchParams();
  body.set("session_id", sessionId);
  const r = await fetch(${PY}/pause, { method: "POST", body });
  return r.json();
}

export async function resumeAgent(sessionId: string) {
  const body = new URLSearchParams();
  body.set("session_id", sessionId);
  const r = await fetch(${PY}/resume, { method: "POST", body });
  return r.json();
}

export async function getStatus(sessionId: string) {
  const r = await fetch(${PY}/status/${sessionId});
  return r.json();
}
server/src/middleware/sizeLimit.ts
ts
Copy
Edit
import multer from "multer";
import { RequestHandler } from "express";

export function sizeLimit(maxMb: number): [RequestHandler, RequestHandler] {
  const upload = multer({ limits: { fileSize: maxMb * 1024 * 1024 } });
  return [upload.any(), (req, _res, next) => next()];
}
server/src/middleware/auth.ts
ts
Copy
Edit
import admin from "firebase-admin";
import { Request, Response, NextFunction } from "express";

let inited = false;
function ensureFirebase() {
  if (!inited) {
    admin.initializeApp({ credential: admin.credential.applicationDefault() });
    inited = true;
  }
}

export async function authRequired(req: Request, res: Response, next: NextFunction) {
  ensureFirebase();
  const hdr = req.headers.authorization || "";
  const token = hdr.startsWith("Bearer ") ? hdr.slice(7) : "";
  if (!token) return res.status(401).json({ error: "NO_TOKEN" });
  try {
    const decoded = await admin.auth().verifyIdToken(token);
    (req as any).uid = decoded.uid;
    (req as any).email = decoded.email;
    next();
  } catch {
    res.status(401).json({ error: "INVALID_TOKEN" });
  }
}
server/src/middleware/entitlement.ts
ts
Copy
Edit
import { Request, Response, NextFunction } from "express";
import { PrismaClient } from "@prisma/client";
import { nowIST, toISTKey } from "../services/time";
import { getTrialState, consumeToday, TRIAL_CONSTANTS } from "../services/trialRules";
import { resetUserSessions } from "../services/trialUsage";

const db = new PrismaClient();

export async function requirePremium(req: Request, res: Response, next: NextFunction) {
  const email = (req as any).email as string;
  if (!email) return res.status(401).json({ error: "UNAUTHENTICATED" });

  const user = await db.user.findUnique({ where: { email }, include: { subscription: true } });
  if (!user) return res.status(401).json({ error: "UNAUTHENTICATED" });

  const now = nowIST();

  // Subscribers pass
  const subActive =
    user.subscription?.status === "active" &&
    user.subscription.currentPeriodEnd &&
    now < user.subscription.currentPeriodEnd;
  if (subActive) return next();

  // Trial evaluation
  const state = await getTrialState(email);
  if (!state.allowed) {
    await resetUserSessions(email);
    return res.status(402).json({ error: "PAYMENT_REQUIRED", reason: state.reason || "TRIAL_NOT_ALLOWED" });
  }

  // If need initialization (first ever trial use), or new trial day consumption, consume a day
  if ((state as any).needInit || (state.remainingDays > 0 && !state.usedDates.includes(state.todayKey))) {
    try {
      await consumeToday(email);
    } catch (e: any) {
      await resetUserSessions(email);
      return res.status(402).json({ error: "PAYMENT_REQUIRED", reason: e.message || "TRIAL_DAYS_EXHAUSTED" });
    }
  }

  // Daily seconds remaining check
  const todayKey = toISTKey(now);
  const dailyUsed = user.trialDailyKey === todayKey ? (user.trialDailyUsedSeconds || 0) : 0;
  const dailyLeft = Math.max(0, TRIAL_CONSTANTS.DAILY_SECONDS - dailyUsed);
  if (dailyLeft <= 0) {
    await resetUserSessions(email);
    return res.status(402).json({ error: "PAYMENT_REQUIRED", reason: "DAILY_LIMIT_REACHED" });
  }

  // Stash remaining seconds for watchdog
  (req as any).__trialRemainingSeconds = dailyLeft;
  next();
}

/** Paid-only gate */
export async function isSubscriber(req: Request, res: Response, next: NextFunction) {
  const email = (req as any).email as string;
  const user = await db.user.findUnique({ where: { email }, include: { subscription: true } });
  const now = nowIST();
  const ok =
    !!user &&
    user.subscription?.status === "active" &&
    user.subscription.currentPeriodEnd &&
    now < user.subscription.currentPeriodEnd;
  if (!ok) return res.status(402).json({ error: "SUBSCRIBER_ONLY" });
  next();
}
server/src/routes/users.ts
ts
Copy
Edit
import { Router } from "express";
import { PrismaClient } from "@prisma/client";
import { authRequired } from "../middleware/auth";
import { nowIST, toISTKey } from "../services/time";
import { sendWelcome } from "../services/email";

const db = new PrismaClient();
export const users = Router();

users.post("/api/auth/login", authRequired, async (req, res) => {
  const email = (req as any).email as string;
  const name = (req.body?.name || "") as string;

  const created = await db.user.upsert({
    where: { email },
    create: {
      email, name, authProvider: "firebase",
      // On first login, don’t consume a trial day yet; welcome email goes out
    },
    update: {}
  });

  if (created && created.createdAt.getTime() === created.updatedAt?.getTime()) {
    try { await sendWelcome(email, name); } catch {}
  }

  res.json({ ok: true });
});

users.get("/api/me", authRequired, async (req, res) => {
  const email = (req as any).email as string;
  const user = await db.user.findUnique({ where: { email }, include: { subscription: true } });
  res.json(user);
});
server/src/routes/payments.razorpay.ts
ts
Copy
Edit
import { Router } from "express";
import Razorpay from "razorpay";
import { PrismaClient } from "@prisma/client";
import { authRequired } from "../middleware/auth";

const db = new PrismaClient();
const payments = Router();
export { payments };

const razor = new Razorpay({
  key_id: process.env.RAZORPAY_KEY_ID!,
  key_secret: process.env.RAZORPAY_KEY_SECRET!
});

payments.post("/api/payments/create-subscription", authRequired, async (req, res) => {
  const email = (req as any).email as string;
  const user = await db.user.findUnique({ where: { email } });
  if (!user) return res.status(401).json({ error: "UNAUTHENTICATED" });

  const sub = await razor.subscriptions.create({
    plan_id: process.env.PLAN_MONTHLY_ID!,
    total_count: 12,
    customer_notify: 1
  });

  await db.subscription.upsert({
    where: { userId: user.id },
    create: {
      userId: user.id,
      provider: "razorpay",
      providerCustomerId: email,
      providerSubId: sub.id,
      status: "active",
      currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
    },
    update: {
      providerSubId: sub.id,
      status: "active",
      currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
    }
  });

  res.json({ subscriptionId: sub.id, checkout: { provider: "razorpay", sub } });
});

payments.post("/api/payments/webhook", async (req, res) => {
  const event = req.body;
  try {
    const subEntity = event?.payload?.subscription?.entity;
    if (subEntity?.id) {
      const dbSub = await db.subscription.findFirst({ where: { providerSubId: subEntity.id } });
      if (dbSub) {
        const statusMap: any = {
          active: "active",
          completed: "expired",
          canceled: "canceled",
          halted: "expired",
          paused: "canceled"
        };
        await db.subscription.update({
          where: { id: dbSub.id },
          data: {
            status: statusMap[subEntity.status] || "active",
            currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
          }
        });
      }
    }
  } catch { /* ignore */ }
  res.json({ ok: true });
});
server/src/routes/admin.ts
ts
Copy
Edit
import { Router } from "express";
import { PrismaClient } from "@prisma/client";
import { authRequired } from "../middleware/auth";

const db = new PrismaClient();
export const admin = Router();

function adminOnly(req: any, res: any, next: any) {
  const allow = (process.env.ADMIN_EMAILS || "").split(",").map(s => s.trim().toLowerCase());
  if (allow.includes((req.email || "").toLowerCase())) return next();
  return res.status(403).json({ error: "FORBIDDEN" });
}

admin.get("/api/admin/users", authRequired, adminOnly, async (_req, res) => {
  const users = await db.user.findMany({ include: { subscription: true } });
  res.json(users);
});

admin.get("/api/admin/usage", authRequired, adminOnly, async (_req, res) => {
  const events = await db.usageEvent.findMany({ orderBy: { createdAt: "desc" }, take: 500 });
  res.json(events);
});
server/src/routes/files.upload.ts
ts
Copy
Edit
import { Router } from "express";
import multer from "multer";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";

const upload = multer({ storage: multer.memoryStorage() });
export const filesUpload = Router();

// 25MB guard is enforced by sizeLimit middleware globally
filesUpload.post("/api/files/upload", authRequired, requirePremium, upload.single("file"), async (req, res) => {
  if (!req.file) return res.status(400).json({ error: "NO_FILE" });
  const allowed = ["application/pdf", "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "text/csv"];
  if (!allowed.includes(req.file.mimetype)) return res.status(415).json({ error: "UNSUPPORTED_TYPE" });
  // You can store S3/local here; for now echo meta
  res.json({ ok: true, name: req.file.originalname, size: req.file.size, type: req.file.mimetype });
});
server/src/routes/files.download.ts
ts
Copy
Edit
import { Router } from "express";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";
import { createWorkbookBuffer } from "../services/xlsxWriter";

export const filesDownload = Router();

filesDownload.get("/api/files/download/remarks.xlsx", authRequired, requirePremium, async (_req, res) => {
  const wb = await createWorkbookBuffer([{ title: "Sample", remark: "OK", severity: "low" }]);
  res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
  res.setHeader("Content-Disposition", 'attachment; filename="remarks.xlsx"');
  res.send(wb);
});
server/src/routes/files.analyze.ts
ts
Copy
Edit
import { Router } from "express";
import multer from "multer";
import mammoth from "mammoth";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";
import { createWorkbookBuffer } from "../services/xlsxWriter";
import pdf from "pdf-parse";

const upload = multer({ storage: multer.memoryStorage() });
export const filesAnalyze = Router();

async function extractText(mimetype: string, buf: Buffer) {
  if (mimetype === "application/pdf") {
    const out = await pdf(buf);
    return out.text || "";
  }
  if (mimetype === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
    const out = await mammoth.extractRawText({ buffer: buf });
    return out.value || "";
  }
  if (mimetype === "text/csv" || mimetype.includes("spreadsheetml")) {
    return buf.toString("utf8");
  }
  return "";
}

filesAnalyze.post("/api/files/analyze", authRequired, requirePremium, upload.single("file"), async (req, res) => {
  if (!req.file) return res.status(400).json({ error: "NO_FILE" });
  const text = await extractText(req.file.mimetype, req.file.buffer);

  // Very simple heuristic “remarking”
  const rows = text.split(/\n+/).slice(0, 200).filter(Boolean).map((line, i) => ({
    title: line.slice(0, 80),
    remark: line.length > 80 ? "Long line" : "OK",
    severity: line.toLowerCase().includes("error") ? "high" : "low",
    idx: i + 1
  }));

  const wb = await createWorkbookBuffer(rows);
  res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
  res.setHeader("Content-Disposition", attachment; filename="remarks.xlsx");
  res.send(wb);
});
Install extra deps: npm i pdf-parse mammoth.

server/src/routes/sheets.map.preview.ts
ts
Copy
Edit
import { Router } from "express";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";

export const sheetsMapPreview = Router();

sheetsMapPreview.post("/api/sheets/map/preview", authRequired, requirePremium, async (req, res) => {
  const { rows } = req.body || {};
  const diff = { adds: rows?.length || 0, updates: 0, deletes: 0 };
  res.json({ ok: true, diff });
});
server/src/routes/sheets.map.apply.ts
ts
Copy
Edit
import { Router } from "express";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";

export const sheetsMapApply = Router();

sheetsMapApply.post("/api/sheets/map/apply", authRequired, requirePremium, async (_req, res) => {
  res.json({ ok: true, upserted: 42 });
});
server/src/services/xlsxWriter.ts
ts
Copy
Edit
import ExcelJS from "exceljs";

export async function createWorkbookBuffer(rows: any[]) {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet("Remarks");
  ws.columns = [
    { header: "Title", key: "title", width: 50 },
    { header: "Remark", key: "remark", width: 30 },
    { header: "Severity", key: "severity", width: 12 }
  ];
  rows.forEach(r => ws.addRow({ title: r.title, remark: r.remark, severity: r.severity }));
  return wb.xlsx.writeBuffer();
}
Install: npm i exceljs

server/src/services/mergeEngine.ts
ts
Copy
Edit
export function mergeRows(target: any[], incoming: any[], key: string) {
  const map = new Map(target.map((r) => [r[key], r]));
  incoming.forEach(r => map.set(r[key], { ...map.get(r[key]), ...r }));
  return Array.from(map.values());
}
server/src/services/email.ts
ts
Copy
Edit
import sg from "@sendgrid/mail";
sg.setApiKey(process.env.SENDGRID_API_KEY!);

export async function sendWelcome(email: string, name?: string) {
  try {
    await sg.send({
      to: email,
      from: "welcome@agentbrowse.app",
      subject: "Welcome to AgentBrowse ✨",
      html: <p>Hi ${name || ""}, your account is ready. You have a 5‑day trial (15 minutes per IST day) within 30 days.</p>
    });
  } catch {}
}
server/src/index.ts
ts
Copy
Edit
import "dotenv/config";
import express from "express";
import cors from "cors";
import { sizeLimit } from "./middleware/sizeLimit";
import { users } from "./routes/users";
import { payments } from "./routes/payments.razorpay";
import { admin } from "./routes/admin";
import { filesUpload } from "./routes/files.upload";
import { filesDownload } from "./routes/files.download";
import { sheetsMapPreview } from "./routes/sheets.map.preview";
import { sheetsMapApply } from "./routes/sheets.map.apply";
import { filesAnalyze } from "./routes/files.analyze";
import { authRequired } from "./middleware/auth";
import { requirePremium, isSubscriber } from "./middleware/entitlement";
import { startAgent, stopAgent, pauseAgent, resumeAgent } from "./services/pythonAgent";
import { beginTrialSession, endTrialSession } from "./services/trialUsage";

const app = express();
const origins = (process.env.CORS_ORIGINS || "").split(",").filter(Boolean);
app.use(cors({ origin: origins.length ? origins : true, credentials: true }));
app.use(...sizeLimit(Number(process.env.MAX_UPLOAD_MB || 25)));
app.use(express.json());

app.use(users);
app.use(payments);
app.use(admin);
app.use(filesUpload);
app.use(filesDownload);
app.use(filesAnalyze);
app.use(sheetsMapPreview);
app.use(sheetsMapApply);

app.post("/api/agent/start", authRequired, requirePremium, async (req, res) => {
  const { sessionId, task, model } = req.body || {};
  if (!sessionId || !task) return res.status(400).json({ error: "BAD_REQUEST" });
  const email = (req as any).email as string;
  await beginTrialSession(email, sessionId);

  // pass watchdog budget to python
  const maxSeconds: number | undefined = (req as any).__trialRemainingSeconds;
  const out = await startAgent(sessionId, task, model, maxSeconds);
  res.json(out);
});

app.post("/api/agent/stop", authRequired, requirePremium, async (req, res) => {
  const { sessionId } = req.body || {};
  if (!sessionId) return res.status(400).json({ error: "BAD_REQUEST" });
  const email = (req as any).email as string;
  await endTrialSession(email, sessionId);
  const out = await stopAgent(sessionId);
  res.json(out);
});

// Paid-only
app.post("/api/agent/pause", authRequired, isSubscriber, async (req, res) => {
  const { sessionId } = req.body || {};
  if (!sessionId) return res.status(400).json({ error: "BAD_REQUEST" });
  const out = await pauseAgent(sessionId);
  res.json(out);
});

app.post("/api/agent/resume", authRequired, isSubscriber, async (req, res) => {
  const { sessionId } = req.body || {};
  if (!sessionId) return res.status(400).json({ error: "BAD_REQUEST" });
  const out = await resumeAgent(sessionId);
  res.json(out);
});

const port = Number(process.env.PORT || 7070);
app.listen(port, () => console.log(Server listening on :${port}));
2) PYTHON BACKEND (FastAPI + browser-use)
REPLACE these three files verbatim (as you asked). I’ve added a watchdog that cancels the agent at the exact second budget is exhausted.

python_backend/requirements.txt
ini
Copy
Edit
fastapi==0.111.0
uvicorn==0.30.0
browser-use==0.1.0
playwright==1.46.0
websockets==12.0
pydantic==2.8.2
python_backend/main.py (REPLACE)
python
Copy
Edit
#!/usr/bin/env python3
"""
Integrated Agent Repository with Browser-Use Technology
FastAPI backend that runs an agent and streams logs/progress over WebSocket.
"""
import asyncio
import logging
from typing import Dict, Optional, Any, Callable

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn

from websocket_manager import WebSocketManager
from agent_browser_controller import AgentBrowserController

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(name)s: %(message)s")
logger = logging.getLogger("python_backend")

app = FastAPI(title="AgentBrowse Python Backend", version="0.1.0")
ws_manager = WebSocketManager()
controller = AgentBrowserController()

# in-memory sessions
SESSIONS: Dict[str, Dict[str, Any]] = {}

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
async def health():
    return {"status": "ok"}

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket, session_id: Optional[str] = None):
    await ws_manager.connect(websocket, {"session_id": session_id or "default"})
    try:
        while True:
            data = await websocket.receive_json()
            if isinstance(data, dict) and data.get("type") == "ping":
                await websocket.send_json({"type": "pong"})
    except WebSocketDisconnect:
        await ws_manager.disconnect(websocket)

def _mk_callbacks(session_id: str) -> Dict[str, Callable[..., Any]]:
    async def log(message: str, category: str = "LOG", payload: Optional[dict] = None):
        await ws_manager.broadcast_to_session(session_id, {
            "type": "log",
            "session_id": session_id,
            "category": category,
            "message": message,
            "payload": payload or {},
        })
    async def progress(phase: str, value: float):
        await ws_manager.broadcast_to_session(session_id, {
            "type": "progress",
            "session_id": session_id,
            "phase": phase,
            "value": value,
        })
    async def snapshot(img_b64: str | None = None):
        await ws_manager.broadcast_to_session(session_id, {
            "type": "snapshot",
            "session_id": session_id,
            "image_b64": img_b64,
        })
    return {"log": log, "progress": progress, "snapshot": snapshot}

@app.post("/start")
async def start(task: str, session_id: str, model: Optional[str] = None, max_seconds: Optional[int] = None):
    if session_id in SESSIONS and SESSIONS[session_id].get("status") == "running":
        return JSONResponse({"error": "already_running"}, status_code=409)

    SESSIONS[session_id] = {"status": "starting"}
    callbacks = _mk_callbacks(session_id)

    async def runner():
        try:
            await callbacks["log"]("Starting agent…", "INIT")
            res = await controller.start_agent(session_id, task, {"model": model, "max_seconds": max_seconds}, callbacks)
            SESSIONS[session_id]["result"] = res
            SESSIONS[session_id]["status"] = "completed"
            await callbacks["log"]("Agent completed", "DONE")
        except asyncio.CancelledError:
            SESSIONS[session_id]["status"] = "stopped"
            await callbacks["log"]("Agent stopped", "STOP")
        except Exception as e:
            logger.exception("Agent failed")
            SESSIONS[session_id]["status"] = "failed"
            SESSIONS[session_id]["error"] = str(e)
            await callbacks["log"](f"Agent error: {e}", "ERROR")

    task_obj = asyncio.create_task(runner(), name=f"agent-{session_id}")
    SESSIONS[session_id]["task"] = task_obj
    SESSIONS[session_id]["status"] = "running"
    return {"session_id": session_id, "status": "running"}

@app.post("/stop")
async def stop(session_id: str):
    sess = SESSIONS.get(session_id)
    if not sess:
        return JSONResponse({"error": "not_found"}, status_code=404)
    t: asyncio.Task = sess.get("task")  # type: ignore
    if t and not t.done():
        t.cancel()
        try:
            await t
        except asyncio.CancelledError:
            pass
    SESSIONS[session_id]["status"] = "stopped"
    return {"session_id": session_id, "status": "stopped"}

@app.post("/pause")
async def pause(session_id: str):
    sess = SESSIONS.get(session_id)
    if not sess:
        return JSONResponse({"error": "not_found"}, status_code=404)
    t = sess.get("task")
    if t and not t.done():
        t.cancel()
        try:
            await t
        except asyncio.CancelledError:
            pass
    SESSIONS[session_id]["status"] = "paused"
    return {"session_id": session_id, "status": "paused"}

@app.post("/resume")
async def resume(session_id: str):
    sess = SESSIONS.get(session_id)
    if not sess or sess.get("status") != "paused":
        return JSONResponse({"error": "not_paused"}, status_code=400)
    last_task = sess.get("result", {}).get("task") or "Resume previous task"
    return await start(task=last_task, session_id=session_id)

@app.get("/status/{session_id}")
async def status(session_id: str):
    return SESSIONS.get(session_id, {"status": "unknown"})

if __name__ == "__main__":
    try:
        import subprocess, sys
        subprocess.run([sys.executable, "-m", "playwright", "install", "chromium", "--with-deps", "--no-shell"], check=False)
    except Exception as e:
        logger.warning(f"Playwright install failed: {e}")
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
python_backend/agent_browser_controller.py (REPLACE; watchdog)
python
Copy
Edit
"""
Agent Browser Controller
Wraps browser_use.Agent and streams events via callbacks with a watchdog timer.
"""
import asyncio
from typing import Any, Dict, Callable, Optional
import logging

from browser_use import Agent
from browser_use.llm import ChatOpenAI

logger = logging.getLogger(__name__)

class AgentBrowserController:
    def __init__(self) -> None:
        pass

    async def start_agent(
        self,
        session_id: str,
        task: str,
        config: Dict[str, Any],
        callbacks: Dict[str, Callable[..., Any]],
    ) -> Dict[str, Any]:
        log = callbacks["log"]
        progress = callbacks["progress"]

        await log("Booting LLM/model…", "INIT")
        model = (config or {}).get("model") or "o4-mini"
        max_seconds: Optional[int] = (config or {}).get("max_seconds")
        llm = ChatOpenAI(model=model, temperature=0.3)

        await log("Creating Agent", "INIT")
        agent = Agent(task=task, llm=llm)

        await progress("Agent Created", 0.2)
        await log("Running agent…", "RUN")

        result = await self._execute_with_monitoring(agent, callbacks, max_seconds)

        await progress("Completed", 1.0)
        return {"result": result, "task": task}

    async def _execute_with_monitoring(
        self, agent: Agent, callbacks: Dict[str, Callable[..., Any]], max_seconds: Optional[int]
    ):
        log = callbacks["log"]
        progress = callbacks["progress"]

        async def _runner():
            return await agent.run()

        task = asyncio.create_task(_runner())
        pct = 0.3

        # Watchdog cancels task exactly when budget ends
        async def watchdog(delay: int):
            try:
                await asyncio.sleep(delay)
                if not task.done():
                    await log("Trial limit reached — stopping navigation.", "TRIAL_EXPIRED")
                    task.cancel()
            except asyncio.CancelledError:
                pass

        wd: Optional[asyncio.Task] = None
        if isinstance(max_seconds, int) and max_seconds > 0:
            wd = asyncio.create_task(watchdog(max_seconds))

        try:
            while not task.done():
                await asyncio.sleep(1.0)
                pct = min(0.95, pct + 0.05)
                await progress("Working", pct)
        except asyncio.CancelledError:
            await log("Execution cancelled", "STOP")
            task.cancel()
            raise
        finally:
            if wd and not wd.done():
                wd.cancel()

        res = await task
        await log("Execution finished", "DONE")
        return res
python_backend/websocket_manager.py (REPLACE)
python
Copy
Edit
"""
WebSocket Manager: tracks connections and allows broadcasting to a session
"""
from typing import Dict, Any, Set
from fastapi import WebSocket
import logging
import json

logger = logging.getLogger(__name__)

class WebSocketManager:
    def __init__(self) -> None:
        self.connections: Set[WebSocket] = set()
        self.connection_data: Dict[WebSocket, Dict[str, Any]] = {}

    async def connect(self, websocket: WebSocket, data: Dict[str, Any] | None = None):
        await websocket.accept()
        self.connections.add(websocket)
        self.connection_data[websocket] = data or {}
        logger.info("WS connected (%s active)", len(self.connections))

    async def disconnect(self, websocket: WebSocket):
        self.connections.discard(websocket)
        self.connection_data.pop(websocket, None)
        try:
            await websocket.close()
        except Exception:
            pass
        logger.info("WS disconnected (%s active)", len(self.connections))

    async def send_to_connection(self, websocket: WebSocket, data: Dict[str, Any]):
        await websocket.send_text(json.dumps(data))

    async def broadcast(self, data: Dict[str, Any]):
        dead = []
        for ws in list(self.connections):
            try:
                await ws.send_text(json.dumps(data))
            except Exception:
                dead.append(ws)
        for ws in dead:
            await self.disconnect(ws)

    async def broadcast_to_session(self, session_id: str, data: Dict[str, Any]):
        for ws, meta in list(self.connection_data.items()):
            if meta.get("session_id") == session_id:
                try:
                    await ws.send_text(json.dumps(data))
                except Exception:
                    await self.disconnect(ws)
3) WEB CLIENT (React/Vite)
Minimal UI to prove end‑to‑end; keep your existing design if you have one.

web/package.json
json
Copy
Edit
{
  "name": "agentbrowse-web",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview --port 5173"
  },
  "dependencies": {
    "firebase": "^10.12.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": { "vite": "^5.2.0", "@types/react": "^18.2.66", "@types/react-dom": "^18.2.22" }
}
web/vite.config.ts
ts
Copy
Edit
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
export default defineConfig({ plugins: [react()], server: { port: 5173 } });
web/src/lib/firebase.ts
ts
Copy
Edit
import { initializeApp } from "firebase/app";
import { getAuth, GoogleAuthProvider } from "firebase/auth";

const cfg = {
  apiKey: import.meta.env.VITE_FB_API_KEY,
  authDomain: import.meta.env.VITE_FB_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FB_PROJECT_ID,
};
export const app = initializeApp(cfg);
export const auth = getAuth(app);
export const google = new GoogleAuthProvider();
web/src/main.tsx
tsx
Copy
Edit
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
createRoot(document.getElementById("root")!).render(<App />);
web/src/App.tsx
tsx
Copy
Edit
import React, { useEffect, useState } from "react";
import { auth, google } from "./lib/firebase";
import { signInWithPopup, signInWithEmailAndPassword, onAuthStateChanged } from "firebase/auth";
import { useWebSocket } from "./hooks/use-websocket";

const API = import.meta.env.VITE_API || "http://localhost:7070";

export default function App() {
  const [me, setMe] = useState<any>(null);
  const [sessionId, setSessionId] = useState("sess-" + Math.random().toString(36).slice(2));
  const [task, setTask] = useState("Open https://example.com and report the H1");
  const [log, setLog] = useState<string[]>([]);
  const ws = useWebSocket(/ws?session_id=${sessionId}, {
    onMessage: (msg) => setLog((l) => [...l.slice(-200), [${msg.category || msg.type}] ${msg.message || ""}])
  });

  useEffect(() => onAuthStateChanged(auth, async (u) => {
    if (!u) { setMe(null); return; }
    const idToken = await u.getIdToken();
    await fetch(${API}/api/auth/login, { method: "POST", headers: { Authorization: Bearer ${idToken}, "Content-Type": "application/json" } });
    const m = await fetch(${API}/api/me, { headers: { Authorization: Bearer ${idToken} } }).then(r => r.json());
    setMe(m);
  }), []);

  async function start() {
    const idToken = await auth.currentUser?.getIdToken();
    const r = await fetch(${API}/api/agent/start, {
      method: "POST",
      headers: { Authorization: Bearer ${idToken}, "Content-Type": "application/json" },
      body: JSON.stringify({ sessionId, task })
    });
    if (!r.ok) alert(await r.text());
  }

  async function stop() {
    const idToken = await auth.currentUser?.getIdToken();
    await fetch(${API}/api/agent/stop, {
      method: "POST",
      headers: { Authorization: Bearer ${idToken}, "Content-Type": "application/json" },
      body: JSON.stringify({ sessionId })
    });
  }

  async function subscribe() {
    const idToken = await auth.currentUser?.getIdToken();
    const r = await fetch(${API}/api/payments/create-subscription, {
      method: "POST",
      headers: { Authorization: Bearer ${idToken} }
    }).then(r => r.json());
    alert("Subscription created on Razorpay: " + r.subscriptionId);
  }

  const isPaid = !!me?.subscription && me.subscription.status === "active";

  return (
    <div style={{ display: "grid", gridTemplateColumns: "360px 1fr", height: "100vh", gap: 8, padding: 8, fontFamily: "Inter, system-ui, sans-serif" }}>
      <div style={{ border: "1px solid #ddd", padding: 12, borderRadius: 8 }}>
        <h3>AgentBrowse</h3>
        {!me ? (
          <>
            <button onClick={() => signInWithPopup(auth, google)}>Sign in with Google</button>
            <p>or set Firebase email/password in code</p>
          </>
        ) : (
          <>
            <div>Signed in as <b>{me.email}</b> {isPaid ? "💎 Paid" : "🧪 Trial"}</div>
            <textarea value={task} onChange={(e) => setTask(e.target.value)} rows={6} style={{ width: "100%", marginTop: 8 }} />
            <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
              <button onClick={start}>Execute</button>
              <button onClick={stop}>Stop</button>
              {isPaid && <button onClick={subscribe}>Re-Subscribe</button>}
            </div>
            {!isPaid && <div style={{ marginTop: 8, color: "#b22" }}>Trial: 5 distinct IST days within 30 days, 15 minutes/day. Auto-stops when time is up.</div>}
          </>
        )}
      </div>
      <div style={{ border: "1px solid #ddd", padding: 12, borderRadius: 8, overflow: "auto" }}>
        <h3>Logs</h3>
        <pre style={{ whiteSpace: "pre-wrap" }}>{log.join("\n")}</pre>
      </div>
    </div>
  );
}
web/src/pages/Pricing.tsx
tsx
Copy
Edit
export default function Pricing(){ return <div>Pricing & Razorpay Checkout placeholder</div>; }
web/src/pages/AdminDashboard.tsx
tsx
Copy
Edit
export default function AdminDashboard(){ return <div>Admin dashboard placeholder</div>; }
web/src/hooks/use-websocket.ts (REPLACE; your provided version)
ts
Copy
Edit
import { useEffect, useRef, useState } from "react";

interface UseWebSocketOptions {
  onMessage?: (data: any) => void;
  onConnect?: () => void;
  onDisconnect?: () => void;
  onError?: (error: Event) => void;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

export function useWebSocket(path: string, options: UseWebSocketOptions = {}) {
  const { onMessage, onConnect, onDisconnect, onError, reconnectInterval = 2000, maxReconnectAttempts = 10 } = options;
  const socketRef = useRef<WebSocket | null>(null);
  const attemptsRef = useRef(0);
  const [connected, setConnected] = useState(false);

  const connect = () => {
    const wsUrl = (() => {
      if (/^wss?:\/\//.test(path)) return path;
      const proto = location.protocol === "https:" ? "wss" : "ws";
      return ${proto}://${location.hostname}:${import.meta.env.VITE_PY_PORT || "8000"}${path};
    })();

    try {
      const s = new WebSocket(wsUrl);
      socketRef.current = s;

      s.onopen = () => {
        setConnected(true);
        attemptsRef.current = 0;
        onConnect?.();
      };

      s.onmessage = (evt) => {
        try { onMessage?.(JSON.parse(evt.data)); } catch {}
      };

      s.onclose = () => {
        setConnected(false);
        onDisconnect?.();
        if (attemptsRef.current < maxReconnectAttempts) {
          attemptsRef.current += 1;
          setTimeout(connect, reconnectInterval);
        }
      };

      s.onerror = (e) => onError?.(e);
    } catch (e) { console.error("WS create failed", e); }
  };

  const disconnect = () => {
    socketRef.current?.close();
    socketRef.current = null;
  };

  const send = (obj: any) => {
    if (socketRef.current && connected) socketRef.current.send(JSON.stringify(obj));
  };

  useEffect(() => { connect(); return () => disconnect(); }, [path]);

  return { connected, send, disconnect };
}
4) HOW TO RUN
Python backend

bash
Copy
Edit
cd python_backend
pip install -r requirements.txt
python main.py
# Health: GET http://localhost:8000/health
Server

bash
Copy
Edit
cd server
npm i
cp .env.example .env   # fill Firebase, Razorpay, SendGrid, PY_BACKEND, ADMIN_EMAILS
npx prisma migrate dev
npm run dev
Web

bash
Copy
Edit
cd web
npm i
# .env (Vite):
# VITE_API=http://localhost:7070
# VITE_PY_PORT=8000
# VITE_FB_API_KEY=...
# VITE_FB_AUTH_DOMAIN=...
# VITE_FB_PROJECT_ID=...
npm run dev
Notes on your rules (confirmed implemented)
Trials: any 5 distinct IST days within 30 days from first consumption; no rollover. Each day grants 15 min. Implemented via:

trialRules.ts (window + day consumption)

entitlement.ts (checks & reasons)

trialUsage.ts (server-timed accounting)

Hard stop at 15 min: Python watchdog cancels the agent exactly when max_seconds elapses. Server passes remaining seconds to /start.

Free users: no Pause/Resume; sessions reset when limit hits.

Paid users: Pause/Resume enabled (/pause, /resume) and guarded by isSubscriber.