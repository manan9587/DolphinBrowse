server/src/routes/users.ts
ts
Copy
Edit
import { Router } from "express";
import { PrismaClient } from "@prisma/client";
import { authRequired } from "../middleware/auth";
import { nowIST, toISTKey } from "../services/time";
import { sendWelcome } from "../services/email";

const db = new PrismaClient();
export const users = Router();

users.post("/api/auth/login", authRequired, async (req, res) => {
  const email = (req as any).email as string;
  const name = (req.body?.name || "") as string;

  const created = await db.user.upsert({
    where: { email },
    create: {
      email, name, authProvider: "firebase",
      // On first login, don’t consume a trial day yet; welcome email goes out
    },
    update: {}
  });

  if (created && created.createdAt.getTime() === created.updatedAt?.getTime()) {
    try { await sendWelcome(email, name); } catch {}
  }

  res.json({ ok: true });
});

users.get("/api/me", authRequired, async (req, res) => {
  const email = (req as any).email as string;
  const user = await db.user.findUnique({ where: { email }, include: { subscription: true } });
  res.json(user);
});
server/src/routes/payments.razorpay.ts
ts
Copy
Edit
import { Router } from "express";
import Razorpay from "razorpay";
import { PrismaClient } from "@prisma/client";
import { authRequired } from "../middleware/auth";

const db = new PrismaClient();
const payments = Router();
export { payments };

const razor = new Razorpay({
  key_id: process.env.RAZORPAY_KEY_ID!,
  key_secret: process.env.RAZORPAY_KEY_SECRET!
});

payments.post("/api/payments/create-subscription", authRequired, async (req, res) => {
  const email = (req as any).email as string;
  const user = await db.user.findUnique({ where: { email } });
  if (!user) return res.status(401).json({ error: "UNAUTHENTICATED" });

  const sub = await razor.subscriptions.create({
    plan_id: process.env.PLAN_MONTHLY_ID!,
    total_count: 12,
    customer_notify: 1
  });

  await db.subscription.upsert({
    where: { userId: user.id },
    create: {
      userId: user.id,
      provider: "razorpay",
      providerCustomerId: email,
      providerSubId: sub.id,
      status: "active",
      currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
    },
    update: {
      providerSubId: sub.id,
      status: "active",
      currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
    }
  });

  res.json({ subscriptionId: sub.id, checkout: { provider: "razorpay", sub } });
});

payments.post("/api/payments/webhook", async (req, res) => {
  const event = req.body;
  try {
    const subEntity = event?.payload?.subscription?.entity;
    if (subEntity?.id) {
      const dbSub = await db.subscription.findFirst({ where: { providerSubId: subEntity.id } });
      if (dbSub) {
        const statusMap: any = {
          active: "active",
          completed: "expired",
          canceled: "canceled",
          halted: "expired",
          paused: "canceled"
        };
        await db.subscription.update({
          where: { id: dbSub.id },
          data: {
            status: statusMap[subEntity.status] || "active",
            currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
          }
        });
      }
    }
  } catch { /* ignore */ }
  res.json({ ok: true });
});
server/src/routes/admin.ts
ts
Copy
Edit
import { Router } from "express";
import { PrismaClient } from "@prisma/client";
import { authRequired } from "../middleware/auth";

const db = new PrismaClient();
export const admin = Router();

function adminOnly(req: any, res: any, next: any) {
  const allow = (process.env.ADMIN_EMAILS || "").split(",").map(s => s.trim().toLowerCase());
  if (allow.includes((req.email || "").toLowerCase())) return next();
  return res.status(403).json({ error: "FORBIDDEN" });
}

admin.get("/api/admin/users", authRequired, adminOnly, async (_req, res) => {
  const users = await db.user.findMany({ include: { subscription: true } });
  res.json(users);
});

admin.get("/api/admin/usage", authRequired, adminOnly, async (_req, res) => {
  const events = await db.usageEvent.findMany({ orderBy: { createdAt: "desc" }, take: 500 });
  res.json(events);
});
server/src/routes/files.upload.ts
ts
Copy
Edit
import { Router } from "express";
import multer from "multer";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";

const upload = multer({ storage: multer.memoryStorage() });
export const filesUpload = Router();

// 25MB guard is enforced by sizeLimit middleware globally
filesUpload.post("/api/files/upload", authRequired, requirePremium, upload.single("file"), async (req, res) => {
  if (!req.file) return res.status(400).json({ error: "NO_FILE" });
  const allowed = ["application/pdf", "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "text/csv"];
  if (!allowed.includes(req.file.mimetype)) return res.status(415).json({ error: "UNSUPPORTED_TYPE" });
  // You can store S3/local here; for now echo meta
  res.json({ ok: true, name: req.file.originalname, size: req.file.size, type: req.file.mimetype });
});
server/src/routes/files.download.ts
ts
Copy
Edit
import { Router } from "express";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";
import { createWorkbookBuffer } from "../services/xlsxWriter";

export const filesDownload = Router();

filesDownload.get("/api/files/download/remarks.xlsx", authRequired, requirePremium, async (_req, res) => {
  const wb = await createWorkbookBuffer([{ title: "Sample", remark: "OK", severity: "low" }]);
  res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
  res.setHeader("Content-Disposition", 'attachment; filename="remarks.xlsx"');
  res.send(wb);
});
server/src/routes/files.analyze.ts
ts
Copy
Edit
import { Router } from "express";
import multer from "multer";
import mammoth from "mammoth";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";
import { createWorkbookBuffer } from "../services/xlsxWriter";
import pdf from "pdf-parse";

const upload = multer({ storage: multer.memoryStorage() });
export const filesAnalyze = Router();

async function extractText(mimetype: string, buf: Buffer) {
  if (mimetype === "application/pdf") {
    const out = await pdf(buf);
    return out.text || "";
  }
  if (mimetype === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
    const out = await mammoth.extractRawText({ buffer: buf });
    return out.value || "";
  }
  if (mimetype === "text/csv" || mimetype.includes("spreadsheetml")) {
    return buf.toString("utf8");
  }
  return "";
}

filesAnalyze.post("/api/files/analyze", authRequired, requirePremium, upload.single("file"), async (req, res) => {
  if (!req.file) return res.status(400).json({ error: "NO_FILE" });
  const text = await extractText(req.file.mimetype, req.file.buffer);

  // Very simple heuristic “remarking”
  const rows = text.split(/\n+/).slice(0, 200).filter(Boolean).map((line, i) => ({
    title: line.slice(0, 80),
    remark: line.length > 80 ? "Long line" : "OK",
    severity: line.toLowerCase().includes("error") ? "high" : "low",
    idx: i + 1
  }));

  const wb = await createWorkbookBuffer(rows);
  res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
  res.setHeader("Content-Disposition", attachment; filename="remarks.xlsx");
  res.send(wb);
});
Install extra deps: npm i pdf-parse mammoth.

server/src/routes/sheets.map.preview.ts
ts
Copy
Edit
import { Router } from "express";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";

export const sheetsMapPreview = Router();

sheetsMapPreview.post("/api/sheets/map/preview", authRequired, requirePremium, async (req, res) => {
  const { rows } = req.body || {};
  const diff = { adds: rows?.length || 0, updates: 0, deletes: 0 };
  res.json({ ok: true, diff });
});
server/src/routes/sheets.map.apply.ts
ts
Copy
Edit
import { Router } from "express";
import { authRequired } from "../middleware/auth";
import { requirePremium } from "../middleware/entitlement";

export const sheetsMapApply = Router();

sheetsMapApply.post("/api/sheets/map/apply", authRequired, requirePremium, async (_req, res) => {
  res.json({ ok: true, upserted: 42 });
});
server/src/services/xlsxWriter.ts
ts
Copy
Edit
import ExcelJS from "exceljs";

export async function createWorkbookBuffer(rows: any[]) {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet("Remarks");
  ws.columns = [
    { header: "Title", key: "title", width: 50 },
    { header: "Remark", key: "remark", width: 30 },
    { header: "Severity", key: "severity", width: 12 }
  ];
  rows.forEach(r => ws.addRow({ title: r.title, remark: r.remark, severity: r.severity }));
  return wb.xlsx.writeBuffer();
}
Install: npm i exceljs

server/src/services/mergeEngine.ts
ts
Copy
Edit
export function mergeRows(target: any[], incoming: any[], key: string) {
  const map = new Map(target.map((r) => [r[key], r]));
  incoming.forEach(r => map.set(r[key], { ...map.get(r[key]), ...r }));
  return Array.from(map.values());
}
server/src/services/email.ts
ts
Copy
Edit
import sg from "@sendgrid/mail";
sg.setApiKey(process.env.SENDGRID_API_KEY!);

export async function sendWelcome(email: string, name?: string) {
  try {
    await sg.send({
      to: email,
      from: "welcome@agentbrowse.app",
      subject: "Welcome to AgentBrowse ✨",
      html: <p>Hi ${name || ""}, your account is ready. You have a 5‑day trial (15 minutes per IST day) within 30 days.</p>
    });
  } catch {}
}
server/src/index.ts
ts
Copy
Edit
import "dotenv/config";
import express from "express";
import cors from "cors";
import { sizeLimit } from "./middleware/sizeLimit";
import { users } from "./routes/users";
import { payments } from "./routes/payments.razorpay";
import { admin } from "./routes/admin";
import { filesUpload } from "./routes/files.upload";
import { filesDownload } from "./routes/files.download";
import { sheetsMapPreview } from "./routes/sheets.map.preview";
import { sheetsMapApply } from "./routes/sheets.map.apply";
import { filesAnalyze } from "./routes/files.analyze";
import { authRequired } from "./middleware/auth";
import { requirePremium, isSubscriber } from "./middleware/entitlement";
import { startAgent, stopAgent, pauseAgent, resumeAgent } from "./services/pythonAgent";
import { beginTrialSession, endTrialSession } from "./services/trialUsage";

const app = express();
const origins = (process.env.CORS_ORIGINS || "").split(",").filter(Boolean);
app.use(cors({ origin: origins.length ? origins : true, credentials: true }));
app.use(...sizeLimit(Number(process.env.MAX_UPLOAD_MB || 25)));
app.use(express.json());

app.use(users);
app.use(payments);
app.use(admin);
app.use(filesUpload);
app.use(filesDownload);
app.use(filesAnalyze);
app.use(sheetsMapPreview);
app.use(sheetsMapApply);

app.post("/api/agent/start", authRequired, requirePremium, async (req, res) => {
  const { sessionId, task, model } = req.body || {};
  if (!sessionId || !task) return res.status(400).json({ error: "BAD_REQUEST" });
  const email = (req as any).email as string;
  await beginTrialSession(email, sessionId);

  // pass watchdog budget to python
  const maxSeconds: number | undefined = (req as any).__trialRemainingSeconds;
  const out = await startAgent(sessionId, task, model, maxSeconds);
  res.json(out);
});

app.post("/api/agent/stop", authRequired, requirePremium, async (req, res) => {
  const { sessionId } = req.body || {};
  if (!sessionId) return res.status(400).json({ error: "BAD_REQUEST" });
  const email = (req as any).email as string;
  await endTrialSession(email, sessionId);
  const out = await stopAgent(sessionId);
  res.json(out);
});

// Paid-only
app.post("/api/agent/pause", authRequired, isSubscriber, async (req, res) => {
  const { sessionId } = req.body || {};
  if (!sessionId) return res.status(400).json({ error: "BAD_REQUEST" });
  const out = await pauseAgent(sessionId);
  res.json(out);
});

app.post("/api/agent/resume", authRequired, isSubscriber, async (req, res) => {
  const { sessionId } = req.body || {};
  if (!sessionId) return res.status(400).json({ error: "BAD_REQUEST" });
  const out = await resumeAgent(sessionId);
  res.json(out);
});

const port = Number(process.env.PORT || 7070);
app.listen(port, () => console.log(Server listening on :${port}));
2) PYTHON BACKEND (FastAPI + browser-use)
REPLACE these three files verbatim (as you asked). I’ve added a watchdog that cancels the agent at the exact second budget is exhausted.

python_backend/requirements.txt
ini
Copy
Edit
fastapi==0.111.0
uvicorn==0.30.0
browser-use==0.1.0
playwright==1.46.0
websockets==12.0
pydantic==2.8.2
python_backend/main.py (REPLACE)
python
Copy
Edit
#!/usr/bin/env python3
"""
Integrated Agent Repository with Browser-Use Technology
FastAPI backend that runs an agent and streams logs/progress over WebSocket.
"""
import asyncio
import logging
from typing import Dict, Optional, Any, Callable

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn

from websocket_manager import WebSocketManager
from agent_browser_controller import AgentBrowserController

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(name)s: %(message)s")
logger = logging.getLogger("python_backend")

app = FastAPI(title="AgentBrowse Python Backend", version="0.1.0")
ws_manager = WebSocketManager()
controller = AgentBrowserController()

# in-memory sessions
SESSIONS: Dict[str, Dict[str, Any]] = {}

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
async def health():
    return {"status": "ok"}

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket, session_id: Optional[str] = None):
    await ws_manager.connect(websocket, {"session_id": session_id or "default"})
    try:
        while True:
            data = await websocket.receive_json()
            if isinstance(data, dict) and data.get("type") == "ping":
                await websocket.send_json({"type": "pong"})
    except WebSocketDisconnect:
        await ws_manager.disconnect(websocket)

def _mk_callbacks(session_id: str) -> Dict[str, Callable[..., Any]]:
    async def log(message: str, category: str = "LOG", payload: Optional[dict] = None):
        await ws_manager.broadcast_to_session(session_id, {
            "type": "log",
            "session_id": session_id,
            "category": category,
            "message": message,
            "payload": payload or {},
        })
    async def progress(phase: str, value: float):
        await ws_manager.broadcast_to_session(session_id, {
            "type": "progress",
            "session_id": session_id,
            "phase": phase,
            "value": value,
        })
    async def snapshot(img_b64: str | None = None):
        await ws_manager.broadcast_to_session(session_id, {
            "type": "snapshot",
            "session_id": session_id,
            "image_b64": img_b64,
        })
    return {"log": log, "progress": progress, "snapshot": snapshot}

@app.post("/start")
async def start(task: str, session_id: str, model: Optional[str] = None, max_seconds: Optional[int] = None):
    if session_id in SESSIONS and SESSIONS[session_id].get("status") == "running":
        return JSONResponse({"error": "already_running"}, status_code=409)

    SESSIONS[session_id] = {"status": "starting"}
    callbacks = _mk_callbacks(session_id)

    async def runner():
        try:
            await callbacks["log"]("Starting agent…", "INIT")
            res = await controller.start_agent(session_id, task, {"model": model, "max_seconds": max_seconds}, callbacks)
            SESSIONS[session_id]["result"] = res
            SESSIONS[session_id]["status"] = "completed"
            await callbacks["log"]("Agent completed", "DONE")
        except asyncio.CancelledError:
            SESSIONS[session_id]["status"] = "stopped"
            await callbacks["log"]("Agent stopped", "STOP")
        except Exception as e:
            logger.exception("Agent failed")
            SESSIONS[session_id]["status"] = "failed"
            SESSIONS[session_id]["error"] = str(e)
            await callbacks["log"](f"Agent error: {e}", "ERROR")

    task_obj = asyncio.create_task(runner(), name=f"agent-{session_id}")
    SESSIONS[session_id]["task"] = task_obj
    SESSIONS[session_id]["status"] = "running"
    return {"session_id": session_id, "status": "running"}

@app.post("/stop")
async def stop(session_id: str):
    sess = SESSIONS.get(session_id)
    if not sess:
        return JSONResponse({"error": "not_found"}, status_code=404)
    t: asyncio.Task = sess.get("task")  # type: ignore
    if t and not t.done():
        t.cancel()
        try:
            await t
        except asyncio.CancelledError:
            pass
    SESSIONS[session_id]["status"] = "stopped"
    return {"session_id": session_id, "status": "stopped"}

@app.post("/pause")
async def pause(session_id: str):
    sess = SESSIONS.get(session_id)
    if not sess:
        return JSONResponse({"error": "not_found"}, status_code=404)
    t = sess.get("task")
    if t and not t.done():
        t.cancel()
        try:
            await t
        except asyncio.CancelledError:
            pass
    SESSIONS[session_id]["status"] = "paused"
    return {"session_id": session_id, "status": "paused"}

@app.post("/resume")
async def resume(session_id: str):
    sess = SESSIONS.get(session_id)
    if not sess or sess.get("status") != "paused":
        return JSONResponse({"error": "not_paused"}, status_code=400)
    last_task = sess.get("result", {}).get("task") or "Resume previous task"
    return await start(task=last_task, session_id=session_id)

@app.get("/status/{session_id}")
async def status(session_id: str):
    return SESSIONS.get(session_id, {"status": "unknown"})

if __name__ == "__main__":
    try:
        import subprocess, sys
        subprocess.run([sys.executable, "-m", "playwright", "install", "chromium", "--with-deps", "--no-shell"], check=False)
    except Exception as e:
        logger.warning(f"Playwright install failed: {e}")
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
python_backend/agent_browser_controller.py (REPLACE; watchdog)
python
Copy
Edit
"""
Agent Browser Controller
Wraps browser_use.Agent and streams events via callbacks with a watchdog timer.
"""
import asyncio
from typing import Any, Dict, Callable, Optional
import logging

from browser_use import Agent
from browser_use.llm import ChatOpenAI

logger = logging.getLogger(__name__)

class AgentBrowserController:
    def __init__(self) -> None:
        pass

    async def start_agent(
        self,
        session_id: str,
        task: str,
        config: Dict[str, Any],
        callbacks: Dict[str, Callable[..., Any]],
    ) -> Dict[str, Any]:
        log = callbacks["log"]
        progress = callbacks["progress"]

        await log("Booting LLM/model…", "INIT")
        model = (config or {}).get("model") or "o4-mini"
        max_seconds: Optional[int] = (config or {}).get("max_seconds")
        llm = ChatOpenAI(model=model, temperature=0.3)

        await log("Creating Agent", "INIT")
        agent = Agent(task=task, llm=llm)

        await progress("Agent Created", 0.2)
        await log("Running agent…", "RUN")

        result = await self._execute_with_monitoring(agent, callbacks, max_seconds)

        await progress("Completed", 1.0)
        return {"result": result, "task": task}

    async def _execute_with_monitoring(
        self, agent: Agent, callbacks: Dict[str, Callable[..., Any]], max_seconds: Optional[int]
    ):
        log = callbacks["log"]
        progress = callbacks["progress"]

        async def _runner():
            return await agent.run()

        task = asyncio.create_task(_runner())
        pct = 0.3

        # Watchdog cancels task exactly when budget ends
        async def watchdog(delay: int):
            try:
                await asyncio.sleep(delay)
                if not task.done():
                    await log("Trial limit reached — stopping navigation.", "TRIAL_EXPIRED")
                    task.cancel()
            except asyncio.CancelledError:
                pass

        wd: Optional[asyncio.Task] = None
        if isinstance(max_seconds, int) and max_seconds > 0:
            wd = asyncio.create_task(watchdog(max_seconds))

        try:
            while not task.done():
                await asyncio.sleep(1.0)
                pct = min(0.95, pct + 0.05)
                await progress("Working", pct)
        except asyncio.CancelledError:
            await log("Execution cancelled", "STOP")
            task.cancel()
            raise
        finally:
            if wd and not wd.done():
                wd.cancel()

        res = await task
        await log("Execution finished", "DONE")
        return res
python_backend/websocket_manager.py (REPLACE)
python
Copy
Edit
"""
WebSocket Manager: tracks connections and allows broadcasting to a session
"""
from typing import Dict, Any, Set
from fastapi import WebSocket
import logging
import json

logger = logging.getLogger(__name__)

class WebSocketManager:
    def __init__(self) -> None:
        self.connections: Set[WebSocket] = set()
        self.connection_data: Dict[WebSocket, Dict[str, Any]] = {}

    async def connect(self, websocket: WebSocket, data: Dict[str, Any] | None = None):
        await websocket.accept()
        self.connections.add(websocket)
        self.connection_data[websocket] = data or {}
        logger.info("WS connected (%s active)", len(self.connections))

    async def disconnect(self, websocket: WebSocket):
        self.connections.discard(websocket)
        self.connection_data.pop(websocket, None)
        try:
            await websocket.close()
        except Exception:
            pass
        logger.info("WS disconnected (%s active)", len(self.connections))

    async def send_to_connection(self, websocket: WebSocket, data: Dict[str, Any]):
        await websocket.send_text(json.dumps(data))

    async def broadcast(self, data: Dict[str, Any]):
        dead = []
        for ws in list(self.connections):
            try:
                await ws.send_text(json.dumps(data))
            except Exception:
                dead.append(ws)
        for ws in dead:
            await self.disconnect(ws)

    async def broadcast_to_session(self, session_id: str, data: Dict[str, Any]):
        for ws, meta in list(self.connection_data.items()):
            if meta.get("session_id") == session_id:
                try:
                    await ws.send_text(json.dumps(data))
                except Exception:
                    await self.disconnect(ws)
3) WEB CLIENT (React/Vite)
Minimal UI to prove end‑to‑end; keep your existing design if you have one.

web/package.json
json
Copy
Edit
{
  "name": "agentbrowse-web",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview --port 5173"
  },
  "dependencies": {
    "firebase": "^10.12.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": { "vite": "^5.2.0", "@types/react": "^18.2.66", "@types/react-dom": "^18.2.22" }
}
web/vite.config.ts
ts
Copy
Edit
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
export default defineConfig({ plugins: [react()], server: { port: 5173 } });
web/src/lib/firebase.ts
ts
Copy
Edit
import { initializeApp } from "firebase/app";
import { getAuth, GoogleAuthProvider } from "firebase/auth";

const cfg = {
  apiKey: import.meta.env.VITE_FB_API_KEY,
  authDomain: import.meta.env.VITE_FB_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FB_PROJECT_ID,
};
export const app = initializeApp(cfg);
export const auth = getAuth(app);
export const google = new GoogleAuthProvider();
web/src/main.tsx
tsx
Copy
Edit
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
createRoot(document.getElementById("root")!).render(<App />);
web/src/App.tsx
tsx
Copy
Edit
import React, { useEffect, useState } from "react";
import { auth, google } from "./lib/firebase";
import { signInWithPopup, signInWithEmailAndPassword, onAuthStateChanged } from "firebase/auth";
import { useWebSocket } from "./hooks/use-websocket";

const API = import.meta.env.VITE_API || "http://localhost:7070";

export default function App() {
  const [me, setMe] = useState<any>(null);
  const [sessionId, setSessionId] = useState("sess-" + Math.random().toString(36).slice(2));
  const [task, setTask] = useState("Open https://example.com and report the H1");
  const [log, setLog] = useState<string[]>([]);
  const ws = useWebSocket(/ws?session_id=${sessionId}, {
    onMessage: (msg) => setLog((l) => [...l.slice(-200), [${msg.category || msg.type}] ${msg.message || ""}])
  });

  useEffect(() => onAuthStateChanged(auth, async (u) => {
    if (!u) { setMe(null); return; }
    const idToken = await u.getIdToken();
    await fetch(${API}/api/auth/login, { method: "POST", headers: { Authorization: Bearer ${idToken}, "Content-Type": "application/json" } });
    const m = await fetch(${API}/api/me, { headers: { Authorization: Bearer ${idToken} } }).then(r => r.json());
    setMe(m);
  }), []);

  async function start() {
    const idToken = await auth.currentUser?.getIdToken();
    const r = await fetch(${API}/api/agent/start, {
      method: "POST",
      headers: { Authorization: Bearer ${idToken}, "Content-Type": "application/json" },
      body: JSON.stringify({ sessionId, task })
    });
    if (!r.ok) alert(await r.text());
  }

  async function stop() {
    const idToken = await auth.currentUser?.getIdToken();
    await fetch(${API}/api/agent/stop, {
      method: "POST",
      headers: { Authorization: Bearer ${idToken}, "Content-Type": "application/json" },
      body: JSON.stringify({ sessionId })
    });
  }

  async function subscribe() {
    const idToken = await auth.currentUser?.getIdToken();
    const r = await fetch(${API}/api/payments/create-subscription, {
      method: "POST",
      headers: { Authorization: Bearer ${idToken} }
    }).then(r => r.json());
    alert("Subscription created on Razorpay: " + r.subscriptionId);
  }

  const isPaid = !!me?.subscription && me.subscription.status === "active";

  return (
    <div style={{ display: "grid", gridTemplateColumns: "360px 1fr", height: "100vh", gap: 8, padding: 8, fontFamily: "Inter, system-ui, sans-serif" }}>
      <div style={{ border: "1px solid #ddd", padding: 12, borderRadius: 8 }}>
        <h3>AgentBrowse</h3>
        {!me ? (
          <>
            <button onClick={() => signInWithPopup(auth, google)}>Sign in with Google</button>
            <p>or set Firebase email/password in code</p>
          </>
        ) : (
          <>
            <div>Signed in as <b>{me.email}</b> {isPaid ? "💎 Paid" : "🧪 Trial"}</div>
            <textarea value={task} onChange={(e) => setTask(e.target.value)} rows={6} style={{ width: "100%", marginTop: 8 }} />
            <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
              <button onClick={start}>Execute</button>
              <button onClick={stop}>Stop</button>
              {isPaid && <button onClick={subscribe}>Re-Subscribe</button>}
            </div>
            {!isPaid && <div style={{ marginTop: 8, color: "#b22" }}>Trial: 5 distinct IST days within 30 days, 15 minutes/day. Auto-stops when time is up.</div>}
          </>
        )}
      </div>
      <div style={{ border: "1px solid #ddd", padding: 12, borderRadius: 8, overflow: "auto" }}>
        <h3>Logs</h3>
        <pre style={{ whiteSpace: "pre-wrap" }}>{log.join("\n")}</pre>
      </div>
    </div>
  );
}
web/src/pages/Pricing.tsx
tsx
Copy
Edit
export default function Pricing(){ return <div>Pricing & Razorpay Checkout placeholder</div>; }
web/src/pages/AdminDashboard.tsx
tsx
Copy
Edit
export default function AdminDashboard(){ return <div>Admin dashboard placeholder</div>; }
web/src/hooks/use-websocket.ts (REPLACE; your provided version)
ts
Copy
Edit
import { useEffect, useRef, useState } from "react";

interface UseWebSocketOptions {
  onMessage?: (data: any) => void;
  onConnect?: () => void;
  onDisconnect?: () => void;
  onError?: (error: Event) => void;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

export function useWebSocket(path: string, options: UseWebSocketOptions = {}) {
  const { onMessage, onConnect, onDisconnect, onError, reconnectInterval = 2000, maxReconnectAttempts = 10 } = options;
  const socketRef = useRef<WebSocket | null>(null);
  const attemptsRef = useRef(0);
  const [connected, setConnected] = useState(false);

  const connect = () => {
    const wsUrl = (() => {
      if (/^wss?:\/\//.test(path)) return path;
      const proto = location.protocol === "https:" ? "wss" : "ws";
      return ${proto}://${location.hostname}:${import.meta.env.VITE_PY_PORT || "8000"}${path};
    })();

    try {
      const s = new WebSocket(wsUrl);
      socketRef.current = s;

      s.onopen = () => {
        setConnected(true);
        attemptsRef.current = 0;
        onConnect?.();
      };

      s.onmessage = (evt) => {
        try { onMessage?.(JSON.parse(evt.data)); } catch {}
      };

      s.onclose = () => {
        setConnected(false);
        onDisconnect?.();
        if (attemptsRef.current < maxReconnectAttempts) {
          attemptsRef.current += 1;
          setTimeout(connect, reconnectInterval);
        }
      };

      s.onerror = (e) => onError?.(e);
    } catch (e) { console.error("WS create failed", e); }
  };

  const disconnect = () => {
    socketRef.current?.close();
    socketRef.current = null;
  };

  const send = (obj: any) => {
    if (socketRef.current && connected) socketRef.current.send(JSON.stringify(obj));
  };

  useEffect(() => { connect(); return () => disconnect(); }, [path]);

  return { connected, send, disconnect };
}
4) HOW TO RUN
Python backend

bash
Copy
Edit
cd python_backend
pip install -r requirements.txt
python main.py
# Health: GET http://localhost:8000/health
Server

bash
Copy
Edit
cd server
npm i
cp .env.example .env   # fill Firebase, Razorpay, SendGrid, PY_BACKEND, ADMIN_EMAILS
npx prisma migrate dev
npm run dev
Web

bash
Copy
Edit
cd web
npm i
# .env (Vite):
# VITE_API=http://localhost:7070
# VITE_PY_PORT=8000
# VITE_FB_API_KEY=...
# VITE_FB_AUTH_DOMAIN=...
# VITE_FB_PROJECT_ID=...
npm run dev
Notes on your rules (confirmed implemented)
Trials: any 5 distinct IST days within 30 days from first consumption; no rollover. Each day grants 15 min. Implemented via:

trialRules.ts (window + day consumption)

entitlement.ts (checks & reasons)

trialUsage.ts (server-timed accounting)

Hard stop at 15 min: Python watchdog cancels the agent exactly when max_seconds elapses. Server passes remaining seconds to /start.

Free users: no Pause/Resume; sessions reset when limit hits.

Paid users: Pause/Resume enabled (/pause, /resume) and guarded by isSubscriber.